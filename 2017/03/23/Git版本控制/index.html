<!DOCTYPE html>


  <html class="light page-post">


<head>
  <meta charset="utf-8">
  
  <title>Git版本控制 | Laomanco&#39;s Blog</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="Git,技术," />
  

  <meta name="description" content="Git 概览下面这张图是根据自己理解画出来的关于git的一个大概的知识框架图，分别从版本控制的发展,Git的优点,原理和使用的角度队涉及到的知识进行了一个梳理, 最后还有一些遇到过的小问题或者是Tip的总结.  版本控制的发展和历史虽然只有几十年的时间, 但是版本控制已经有着几代的更新,最近几年,Git的发展则出现了一统江湖的局面。仔细想想，除了Git本身的优点之外，存储空间和网络速度的发展，也使">
<meta name="keywords" content="Git,技术">
<meta property="og:type" content="article">
<meta property="og:title" content="Git版本控制">
<meta property="og:url" content="laomanco.com/2017/03/23/Git版本控制/index.html">
<meta property="og:site_name" content="Laomanco's Blog">
<meta property="og:description" content="Git 概览下面这张图是根据自己理解画出来的关于git的一个大概的知识框架图，分别从版本控制的发展,Git的优点,原理和使用的角度队涉及到的知识进行了一个梳理, 最后还有一些遇到过的小问题或者是Tip的总结.  版本控制的发展和历史虽然只有几十年的时间, 但是版本控制已经有着几代的更新,最近几年,Git的发展则出现了一统江湖的局面。仔细想想，除了Git本身的优点之外，存储空间和网络速度的发展，也使">
<meta property="og:image" content="/23/Git版本控制/git_knowledge_map.svg">
<meta property="og:image" content="/23/Git版本控制/version_control.svg">
<meta property="og:image" content="/23/Git版本控制/git_snapshot.png">
<meta property="og:image" content="/23/Git版本控制/git_structure.png">
<meta property="og:image" content="/23/Git版本控制/git_file_states.png">
<meta property="og:image" content="/23/Git版本控制/git_status_bash_2.png">
<meta property="og:image" content="/23/Git版本控制/git_status_vscode.png">
<meta property="og:image" content="/23/Git版本控制/git_clean_bash.png">
<meta property="og:image" content="/23/Git版本控制/git_reset_add.png">
<meta property="og:image" content="/23/Git版本控制/git_reset_add.png">
<meta property="og:image" content="/23/Git版本控制/git_rollback_scenarios.png">
<meta property="og:image" content="/23/Git版本控制/git_reset_commit.png">
<meta property="og:image" content="/23/Git版本控制/git_reset_commit_parameters.png">
<meta property="og:image" content="/23/Git版本控制/reset_vs_revert.png">
<meta property="og:image" content="/23/Git版本控制/git_checkout.png">
<meta property="og:image" content="/23/Git版本控制/submodule.png">
<meta property="og:image" content="/23/Git版本控制/git_submodule_add.png">
<meta property="og:updated_time" content="2017-04-08T07:42:15.990Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Git版本控制">
<meta name="twitter:description" content="Git 概览下面这张图是根据自己理解画出来的关于git的一个大概的知识框架图，分别从版本控制的发展,Git的优点,原理和使用的角度队涉及到的知识进行了一个梳理, 最后还有一些遇到过的小问题或者是Tip的总结.  版本控制的发展和历史虽然只有几十年的时间, 但是版本控制已经有着几代的更新,最近几年,Git的发展则出现了一统江湖的局面。仔细想想，除了Git本身的优点之外，存储空间和网络速度的发展，也使">
<meta name="twitter:image" content="/23/Git版本控制/git_knowledge_map.svg">

  

  
    <link rel="icon" href="/favicon.ico">
  

  <link href="/css/styles.css?v=eaf5ab1e" rel="stylesheet">


  
    <link rel="stylesheet" href="/css/personal-style.css">
  

  

  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?57e94d016e201fba3603a8a2b0263af0";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


</head>

<body>


  
    <span id="toolbox-mobile" class="toolbox-mobile">盒子</span>
  

  <div class="post-header CENTER">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">盒子</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/archives/"
            target="_self"
            >
            博客
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/category/"
            target="_self"
            >
            分类
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/tag/"
            target="_self"
            >
            标签
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/link/"
            target="_self"
            >
            友链
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/about/"
            target="_self"
            >
            关于
          </a>
        </li>
      
    </ul>
  </div>


</div>


  <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Git-概览"><span class="toc-number">1.</span> <span class="toc-text">Git 概览</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#版本控制的发展和历史"><span class="toc-number">1.1.</span> <span class="toc-text">版本控制的发展和历史</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Git的原理和实现机制"><span class="toc-number">2.</span> <span class="toc-text">Git的原理和实现机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#分布式的版本控制系统"><span class="toc-number">2.1.</span> <span class="toc-text">分布式的版本控制系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#保存修改文件的-snapshot-而不是增量"><span class="toc-number">2.2.</span> <span class="toc-text">保存修改文件的 snapshot 而不是增量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#工作区，-暂存区-和-Git仓库"><span class="toc-number">2.3.</span> <span class="toc-text">工作区， 暂存区 和 Git仓库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Git文件的状态和迁移"><span class="toc-number">2.4.</span> <span class="toc-text">Git文件的状态和迁移</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Git的一些使用经验"><span class="toc-number">3.</span> <span class="toc-text">Git的一些使用经验</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Rollback-Clean，Reset-Checkout-Revert的使用"><span class="toc-number">3.1.</span> <span class="toc-text">Rollback: Clean，Reset, Checkout, Revert的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#作用域"><span class="toc-number">3.1.1.</span> <span class="toc-text">作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#主要-Scenarios"><span class="toc-number">3.1.2.</span> <span class="toc-text">主要 Scenarios</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Rollback-from-Create"><span class="toc-number">3.1.2.1.</span> <span class="toc-text">Rollback from Create</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Rollback-from-Add"><span class="toc-number">3.1.2.2.</span> <span class="toc-text">Rollback from Add</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Rollback-from-Commit"><span class="toc-number">3.1.2.3.</span> <span class="toc-text">Rollback from Commit</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Rollback-from-Branch"><span class="toc-number">3.1.2.4.</span> <span class="toc-text">Rollback from Branch</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Merge-on-Conflict"><span class="toc-number">3.1.3.</span> <span class="toc-text">Merge on Conflict</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Git里面的Submodule"><span class="toc-number">3.1.4.</span> <span class="toc-text">Git里面的Submodule</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#添加一个submodule"><span class="toc-number">3.1.4.1.</span> <span class="toc-text">添加一个submodule</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Repository里面有submodule的时候，如何clone"><span class="toc-number">3.1.4.2.</span> <span class="toc-text">Repository里面有submodule的时候，如何clone</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#更新一个submodule"><span class="toc-number">3.1.5.</span> <span class="toc-text">更新一个submodule</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#删除一个submodule"><span class="toc-number">3.1.6.</span> <span class="toc-text">删除一个submodule</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Paging-分页器"><span class="toc-number">3.2.</span> <span class="toc-text">Paging 分页器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Tips"><span class="toc-number">4.</span> <span class="toc-text">Tips</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Config-Git–局部设置与全局设置"><span class="toc-number">4.1.</span> <span class="toc-text">Config Git–局部设置与全局设置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#局部设置"><span class="toc-number">4.1.1.</span> <span class="toc-text">局部设置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#全局设置"><span class="toc-number">4.1.2.</span> <span class="toc-text">全局设置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Git-在-windows-下中文乱码"><span class="toc-number">4.2.</span> <span class="toc-text">Git 在 windows 下中文乱码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Rerence"><span class="toc-number">5.</span> <span class="toc-text">Rerence</span></a></li></ol>
  </div>



<div class="content content-post CENTER">
   <article id="post-Git版本控制" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">Git版本控制</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2017.03.23</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>Laomanco</span>
        </span>
      

      
  <span class="article-category">
    <i class="icon-list"></i>
    <a class="article-category-link" href="/categories/技术/">技术</a>
  </span>



      

    </div>
  </header>

  <div class="article-content">
    
      <h1 id="Git-概览"><a href="#Git-概览" class="headerlink" title="Git 概览"></a>Git 概览</h1><p>下面这张图是根据自己理解画出来的关于git的一个大概的知识框架图，分别从版本控制的发展,Git的优点,原理和使用的角度队涉及到的知识进行了一个梳理, 最后还有一些遇到过的小问题或者是Tip的总结.</p>
<p><img src="/23/Git版本控制/git_knowledge_map.svg" alt=""></p>
<h2 id="版本控制的发展和历史"><a href="#版本控制的发展和历史" class="headerlink" title="版本控制的发展和历史"></a>版本控制的发展和历史</h2><p>虽然只有几十年的时间, 但是版本控制已经有着几代的更新,最近几年,Git的发展则出现了一统江湖的局面。仔细想想，除了Git本身的优点之外，存储空间和网络速度的发展，也使得snapshot这种全量模式对空间/网络传输需求大的问题变得不那么严重，不然Git也不会有今天的江湖地位了。</p>
<p>下面这张图描述了版本控制系统的一个总体概况，里面的绝大多数内容都来自<a href="http://gotgit.readthedocs.io/en/latest/01-meet-git/010-scm-history.html#cvs" target="_blank" rel="external">版本控制的前世和今生</a>，有兴趣的同学可以去查看原文。</p>
<p><img src="/23/Git版本控制/version_control.svg" alt=""></p>
<h1 id="Git的原理和实现机制"><a href="#Git的原理和实现机制" class="headerlink" title="Git的原理和实现机制"></a>Git的原理和实现机制</h1><h2 id="分布式的版本控制系统"><a href="#分布式的版本控制系统" class="headerlink" title="分布式的版本控制系统"></a>分布式的版本控制系统</h2><p>相比于TFS/Subversion/SD这些集中式的版本控制系统，Git采取的是一种分布式的结构, 一个本地的repository就是一个完整的单机版本控制系统,加上服务器上面的remote repository以后,不同主机/用户之间就可以进行分享和协作了。</p>
<h2 id="保存修改文件的-snapshot-而不是增量"><a href="#保存修改文件的-snapshot-而不是增量" class="headerlink" title="保存修改文件的 snapshot 而不是增量"></a>保存修改文件的 snapshot 而不是增量</h2><p>和以前集中式的版本控制系统（SVN…）所不同的是，当某个文件发生修改的时候，Git所保存的是一个全新的备份。如下图所示：</p>
<div align="center"><br><img src="/23/Git版本控制/git_snapshot.png" width="80%" align="center"><br></div>

<p>这样带来的好处是切换速度快，要查看某个版本（某个commit）的project信息的时候，只需要把对应的文件拿出来就可以，所以Git从任意一个版本都能够很方便的进行build或者是拆分出新的branch出来。</p>
<p>而不好的地方就是每次一点点小小的修改都要保存一整个文件的snapshot，这样空间上会非常浪费，从而影响push和get的性能，但是因为Git本身是分布式的，常规的操作都是在本地的repository里面进行的，也就是硬盘读写，加上网络速度和存储空间越来越好，这部分的影响相对会减轻。</p>
<h2 id="工作区，-暂存区-和-Git仓库"><a href="#工作区，-暂存区-和-Git仓库" class="headerlink" title="工作区， 暂存区 和 Git仓库"></a>工作区， 暂存区 和 Git仓库</h2><p>下图给出了Git 版本控制系统的基本机构：</p>
<div align="center"><br><img src="/23/Git版本控制/git_structure.png" width="70%" align="center"><br></div>

<p>它包含四个主要部分：<br><figure class="highlight groovy"><table><tr><td class="code"><pre><div class="line"><span class="number">1.</span> <span class="string">WorkSpace:</span> </div><div class="line">    也叫Working Area或者工作目录，对项目的某个版本独立提取出来的内容。 这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。</div><div class="line"><span class="number">2.</span> <span class="string">StagingArea:</span> </div><div class="line">    也叫做Index或者暂存区域，是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中。</div><div class="line"><span class="number">3.</span> <span class="string">Repository:</span> </div><div class="line">    也叫Git仓库，是 Git 用来保存项目的元数据和对象数据库的地方。 这是 Git 中最重要的部分，从其它计算机克隆仓库时，拷贝的就是这里的数据。</div><div class="line"><span class="number">4.</span> <span class="string">RemoteRepository:</span> </div><div class="line">    网络服务器上面Git Center里面，用来保存Repository的地方，跟本地Repository相对应，通过Pull<span class="regexp">/Push/</span>Clone等方式进行操作。</div></pre></td></tr></table></figure></p>
<p>这四个部分，尤其是前面local的三个部分，构成了我们日常使用Git的主要场景，在尝试过一些git的基本操作，比如下面这些命令以后</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><div class="line"><span class="variable">$ </span>git pull</div><div class="line"><span class="variable">$ </span>git status</div><div class="line"><span class="variable">$ </span>git add .</div><div class="line"><span class="variable">$ </span>git commit -m <span class="string">"xxx"</span></div><div class="line"><span class="variable">$ </span>git push</div></pre></td></tr></table></figure>
<p>需要再进一步的时候，就需要对于这样一个基本结构，还有这些地方与Git管理的文件的状态之间的对应关系有着清晰的认识。</p>
<h2 id="Git文件的状态和迁移"><a href="#Git文件的状态和迁移" class="headerlink" title="Git文件的状态和迁移"></a>Git文件的状态和迁移</h2><p>对应于上面一节提到的Git系统的几个部分，在某个时刻，使用Git管理的文件就有可能处于不同的位置，拥有不同的状态。下面的图就给出了Git文件可能的状态</p>
<div align="center"><br><img src="/23/Git版本控制/git_file_states.png" width="80%" align="center"><br></div>

<p>使用<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ git status <span class="_">-s</span></div></pre></td></tr></table></figure></p>
<p>命令就可以查看新增/修改的文件和状态:</p>
<div align="center"><br><img src="/23/Git版本控制/git_status_bash_2.png" width="70%" align="center"><br></div>

<p>还有一些UI的tool,比如VS Code,会有这更好的状态表示：</p>
<div align="center"><br><img src="/23/Git版本控制/git_status_vscode.png" width="70%" align="center"><br></div>

<p>但是使用命令行仍然是Git最主要和最为方便的模式,因此当你使用了一段时间的Git以后，使用 <em>git status -s</em> 命令查看文件的状态，并且清晰的知道其所在的位置（工作区，暂存区和git repository），和可能的状态转移，以及使用什么命令进行操作，就非常的重要了。这也是区别知道git和真正会用git的很重要一点。</p>
<h1 id="Git的一些使用经验"><a href="#Git的一些使用经验" class="headerlink" title="Git的一些使用经验"></a>Git的一些使用经验</h1><h2 id="Rollback-Clean，Reset-Checkout-Revert的使用"><a href="#Rollback-Clean，Reset-Checkout-Revert的使用" class="headerlink" title="Rollback: Clean，Reset, Checkout, Revert的使用"></a>Rollback: Clean，Reset, Checkout, Revert的使用</h2><p>最初的时候，我们的在git里面对文件的操作都是正向的，也就是 add/commit/push 这些命令，如果有问题，也可以通过修改以后再次提交的方法进行覆盖。但是在管理很多的code的时候，这样人肉的方法就会显得效率很低。</p>
<p>作为版本控制的系统，Git其实已经提供了丰富的命令来支持rollback的操作， 有<br><figure class="highlight elixir"><table><tr><td class="code"><pre><div class="line"><span class="variable">$ </span>git clean</div><div class="line"><span class="variable">$ </span>git reset</div><div class="line"><span class="variable">$ </span>git checkout</div><div class="line"><span class="variable">$ </span>git revert</div></pre></td></tr></table></figure></p>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>Reset/Checkout 命令可以支持在文件level和commit的level进行操作，参数当中是否包含文件路径决定了这些操作是对文件还是对commit有效。</p>
<h3 id="主要-Scenarios"><a href="#主要-Scenarios" class="headerlink" title="主要 Scenarios"></a>主要 Scenarios</h3><p>下面以基本scenario为例，来看看reset操作怎么满足我们rollback的需求。</p>
<p>前面提到过，Git 主要有三个部分组成（不考虑 remote repository）： Workspace，Staging Area 和 Repository。当文件处于他们当中不同的位置（对应不同的状态）的时候，通过对于的操作都可以进行rollback， 以文件123.txt 为例：</p>
<h4 id="Rollback-from-Create"><a href="#Rollback-from-Create" class="headerlink" title="Rollback from Create"></a>Rollback from Create</h4><p>这个时候，文件的状态是 unstaged/untracked， 只是在本地有一个文件而已，要进行删除的话，使用 git clean 命令。<br><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ git clean <span class="_">-f</span></div></pre></td></tr></table></figure></p>
<p>主要的参数有 d/n/f：<br><figure class="highlight haml"><table><tr><td class="code"><pre><div class="line">-<span class="ruby"><span class="symbol">d:</span> 同时删除untracked的目录</span></div><div class="line">-<span class="ruby"><span class="symbol">n:</span> 显示将会做什么，但是不会真的删除文件</span></div><div class="line">-<span class="ruby">f：force， 最终删除文件</span></div></pre></td></tr></table></figure></p>
<div align="center"><br><img src="/23/Git版本控制/git_clean_bash.png" width="70%" align="center"><br></div>

<p>要特别提出的是<a href="">-n</a> 这个参数，会用 <em>“would remove”</em> 提示你将会进行的操作供你检验，但是文件并不会真的被删除<br><figure class="highlight maxima"><table><tr><td class="code"><pre><div class="line">$ git clean -nf <span class="built_in">reset</span>.txt</div><div class="line">Would <span class="built_in">remove</span> <span class="built_in">reset</span>.txt</div></pre></td></tr></table></figure></p>
<p>更详细的内容可以参考 <a href="">git clean –help</a></p>
<h4 id="Rollback-from-Add"><a href="#Rollback-from-Add" class="headerlink" title="Rollback from Add"></a>Rollback from Add</h4><p>如果文件已经使用 git add, 那么文件的状态就是 stacked/modifed, 要把文件从staging area里面去掉，就需要使用 git reset 命令</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><div class="line"><span class="variable">$ </span>git reset <span class="number">123</span>.txt</div></pre></td></tr></table></figure>
<div align="center"><br><img src="/23/Git版本控制/git_reset_add.png" width="70%" align="center"><br></div>

<p>这时候文件就会从staging area里面删掉，然后恢复到workspace。<br>reset 命令还有一些参数来控制rollback的效果，比如说到workspace还是staging area，但是只在只对commit的时候才有用，就放到下面一节描述了。</p>
<p>Rest 到 workspace以后，如果要继续删除，就像上面说的那样，使用 git clean 命令就可以了。</p>
<h4 id="Rollback-from-Commit"><a href="#Rollback-from-Commit" class="headerlink" title="Rollback from Commit"></a>Rollback from Commit</h4><p>如果文件已经用 git commit 提交到repository, 那么文件的状态就是 stacked/modifed, 要把文件从staging area里面去掉，就需要使用 git reset 命令。</p>
<p>前面提到过作用域的问题，reset命令后面是不是带有文件名，将会决定这个rollback操作影响的对象是一个文件还是一整个commit（可以包含多个文件修改）</p>
<blockquote>
<p><strong>1. 文件层面的 reset 操作</strong></p>
</blockquote>
<p>如下所示，如果reset命令后面带有具体的路径，那么commit里面与这个路径/文件不相关的文件就不会被影响。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><div class="line">$ git <span class="keyword">reset</span> <span class="keyword">head</span>^ <span class="number">123.</span>txt</div></pre></td></tr></table></figure>
<div align="center"><br><img src="/23/Git版本控制/git_reset_add.png" width="70%" align="center"><br></div>

<p>这时候文件的snapshot就会从staging area里面删掉，然后恢复到workspace。</p>
<p>下面这张图显示了 clean 和 reset 命令对文件的影响</p>
<div align="center"><br><img src="/23/Git版本控制/git_rollback_scenarios.png" width="60%" align="center"><br></div>


<figure class="highlight sql"><table><tr><td class="code"><pre><div class="line">HEAD 参数：</div><div class="line"></div><div class="line">然后我们注意到，对<span class="keyword">Commit</span>进行<span class="keyword">rollback</span>操作的时候，有个 <span class="keyword">head</span> 的参数，后面还带有^或者是~<span class="number">2</span>这样的符号, 这个参数表明的是<span class="keyword">rollback</span>到哪个<span class="keyword">commit</span>。 <span class="keyword">HEAD</span>其实是一个指针（Git内部结构里面会讲到），指向当前最新的<span class="keyword">commit</span>, <span class="keyword">head</span>^表示的是<span class="keyword">parent</span>，也就是上一个<span class="keyword">commit</span>，<span class="keyword">head</span>^^这是表示再早一个的<span class="keyword">commit</span>。当需要<span class="keyword">rollback</span>到更早的<span class="keyword">commit</span>的时候，则需要使用~n的表示方法，所以<span class="keyword">head</span>^ 跟 <span class="keyword">head</span>~<span class="number">1</span>是等价的。</div></pre></td></tr></table></figure>
<p>要查看head或者head^对应的commit，运行下面的命令就可以了<br><figure class="highlight sql"><table><tr><td class="code"><pre><div class="line">$ git <span class="keyword">show</span> <span class="keyword">head</span></div></pre></td></tr></table></figure></p>
<p>然后还要说明的是，当repository里面只包含一个commit的时候，这个reset命令其实是不起作用的，因为HEAD再往前找不到更早的commit了。但是这个时候因为只有一个commit，reset相当于重新init一个git，所以也并没有关系。</p>
<blockquote>
<p><strong>2. Commit 层面的 reset 操作</strong></p>
</blockquote>
<p>当通过reset来rollback整个commit的时候，其作用域就是所有包含在commit里面的文件。下面的例子说明了两个文件时候的情况。</p>
<div align="center"><br><img src="/23/Git版本控制/git_reset_commit.png" width="70%" align="center"><br></div>

<p>可以看到，commit过的两个文件都被放回到了staging area里面，变成modified的状态了。</p>
<p>需要说明的是，当使用reset命令对commit作用域进行操作的时候，head指针会移动到reset之后的那个commit。所以show head 命令以后，我么看到的commit是init而不是update。</p>
<p>reset 命令还有一些参数来控制rollback的效果，比如说到workspace还是staging area</p>
<figure class="highlight haml"><table><tr><td class="code"><pre><div class="line">-<span class="ruby">-soft – 缓存区和工作目录都不会被改变</span></div><div class="line">-<span class="ruby">-mixed – 默认选项。缓存区和你指定的提交同步，但工作目录不受影响</span></div><div class="line">-<span class="ruby">-hard – 缓存区和工作目录都同步到你指定的提交</span></div></pre></td></tr></table></figure>
<div align="center"><br><img src="/23/Git版本控制/git_reset_commit_parameters.png" width="60%" align="center"><br></div>

<blockquote>
<p><strong>3. 通过 revert 来进行 commit 层面的rollback</strong></p>
</blockquote>
<p>除了 Reset 之外， git 还提供了一个命令 Revert 来进行rollback的操作，但是不同的是， Revert 命令不会往前移动 HEAD，而是会把修改当成一个新的commit 附加在原先的 HEAD 后面，并且移动 HEAD 到最新的 commit。</p>
<div align="center"><br><img src="/23/Git版本控制/reset_vs_revert.png" width="80%" align="center"><br></div>


<h4 id="Rollback-from-Branch"><a href="#Rollback-from-Branch" class="headerlink" title="Rollback from Branch"></a>Rollback from Branch</h4><p>方便的 branch 分支管理是 Git 的一个重要特点，通过新建branch，可以针对一个feature进行独立开发，也可以很容易的在几个人之前share 临时的change （SD 里面可能就需要通过dpk打包之类的方式来实现）。</p>
<p>所以checkout 应该是使用频率仅次于add/commit/push/pull 的命令了，当传入分支名时，可以切换到那个分支。<br><figure class="highlight ebnf"><table><tr><td class="code"><pre><div class="line"><span class="attribute">git checkout hotfix</span></div></pre></td></tr></table></figure></p>
<p>上面这个命令做的不过是将HEAD移到一个新的分支，然后更新工作目录。因为这可能会覆盖本地的修改，Git强制你提交或者缓存工作目录中的所有更改，不然在checkout的时候这些更改都会丢失。和git reset不一样的是，git checkout没有移动这些分支。</p>
<p>下面这张图说明了 checkout 的使用效果。</p>
<div align="center"><br><img src="/23/Git版本控制/git_checkout.png" width="60%" align="center"><br></div>

<p>这一章节总结了git里面rollback相关的主要scenario和相关的解决办法，关于rollback 还有更多细致的分析和别的操作方法，比如checkout到某个commit，以及关于rollback时候，git内部结构的变化，可以参考<a href="https://github.com/geeeeeeeeek/git-recipes/wiki/5.2-代码回滚%EF%BC%9AReset、Checkout、Revert的选择" target="_blank" rel="external">代码回滚：Reset、Checkout、Revert的选择</a></p>
<hr>
<h3 id="Merge-on-Conflict"><a href="#Merge-on-Conflict" class="headerlink" title="Merge on Conflict"></a>Merge on Conflict</h3><hr>
<h3 id="Git里面的Submodule"><a href="#Git里面的Submodule" class="headerlink" title="Git里面的Submodule"></a>Git里面的Submodule</h3><p>submodule 是git里面repository层面进行引用的一种方式, 比如说你的project里面引用到了别人同时开发的另外一个project, 然后大家可以同步更新又保持相互的独立。其作用有点像VS solution里面，project之间的相互引用关系，如果一个修改同时涉及到几个project，那这种方式就会比较方便。</p>
<p>从project层面来说，进行引用一般有三种方式：</p>
<blockquote>
<ol>
<li>合并代码到一起，这样的好处是都可见，但是相互独立性就没那么好了，而且solution会变得很庞大。</li>
<li>通过nuget package之类的方式完全独立起来，只引用稳定release的版本，这样的好处是独立，方便，但是可能没办法同时进行相关的修改。</li>
<li>通过project来进行引用，保持相互的独立的同时，能够在需要的时候进行同时的开发修改。</li>
</ol>
</blockquote>
<p>Git 里面的submodule就是类似于第三种的模式，通过一种link的模式将其他的repository引用进来。需要的时候，进行更新。需要说明的是：</p>
<blockquote>
<ol>
<li>Git的submodule在外层引用者的remote repository里面，只是一个空文件夹形式存在的空文件夹。但是在本地，还是需要将submodule repository的内容同步下来。</li>
<li>Submodule可以跨service完全独立开来，只要是基于git并且拥有访问权限，比如说，通过Github引用一个gitcafe的项目。</li>
</ol>
</blockquote>
<p>下面展示了Hexo Repository里面，通过submodule形式引用fexo主题时候，github上面repository的结构</p>
<div align="center"><br><img src="/23/Git版本控制/submodule.png" width="80%" align="center"><br></div>

<p>利用submodule，就可以将第三方的fexo主题跟我自己的hexo项目分开进行管理了。</p>
<p>在解释了submodule是什么以后，下面介绍一下submodule的使用，包括：</p>
<blockquote>
<ul>
<li>如何添加一个submodule、</li>
<li>Repository里面有submodule的时候，如何clone</li>
<li>如何更新submodule</li>
<li>如何移除submodule</li>
<li>Repository里面有submodule的时候，如何clone</li>
</ul>
</blockquote>
<h4 id="添加一个submodule"><a href="#添加一个submodule" class="headerlink" title="添加一个submodule"></a>添加一个submodule</h4><p>要添加一个submodule的时候，使用 git submodule add 命令：<br><figure class="highlight vim"><table><tr><td class="code"><pre><div class="line">$ git submodule <span class="built_in">add</span> <span class="symbol">&lt;repository&gt;</span> <span class="symbol">&lt;directory&gt;</span></div></pre></td></tr></table></figure></p>
<p>这样就可以吧repository的内容<strong>注册</strong>成directory下面的一个submodule了，比如说通过下面的命令来将fexo注册到我的git repository里面作为一个submodule</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><div class="line">$ git submodule <span class="built_in">add</span> gi<span class="variable">t:</span>//github.<span class="keyword">com</span>/XiaoliangHuang/fexo.git</div></pre></td></tr></table></figure>
<p>然后在repository里面就会生产一个.gitmodules的文件，还有一个fexo的文件夹，里面copy了fexo 这个repository的全部文件.</p>
<div align="center"><br><img src="/23/Git版本控制/git_submodule_add.png" width="70%" align="center"><br></div>

<p>要查看sumodule的状态，可以通过git submodule status命令, 可以看到这个 submodule 已经被注册了并且指向了哪一个commit。<br><figure class="highlight lsl"><table><tr><td class="code"><pre><div class="line">$ git submodule status</div><div class="line"> <span class="number">6</span>cce4cbbd0d27ce7d4207f932bcecb762958be98 fexo (v1<span class="number">.0</span><span class="number">.0</span><span class="number">-58</span>-g6cce4cb)</div></pre></td></tr></table></figure></p>
<h4 id="Repository里面有submodule的时候，如何clone"><a href="#Repository里面有submodule的时候，如何clone" class="headerlink" title="Repository里面有submodule的时候，如何clone"></a>Repository里面有submodule的时候，如何clone</h4><p>当我们添加了一个submodule并且push到了自己的repository里面以后，如果其他人或者自己从其他的电脑上面需要clone这个包含了submodule的repository，要怎么做呢？</p>
<p>默认情况下，git clone 不会下在submodule (会包含空的submodule的folder，和一个.gitmodules文件)，为了达到自己的目的，需要使用<br><figure class="highlight elixir"><table><tr><td class="code"><pre><div class="line"><span class="variable">$ </span>git submodule init</div><div class="line"><span class="variable">$ </span>git submodule update</div><div class="line"><span class="variable">$ </span>git checkout master</div></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ git submodule init</div><div class="line">Submodule <span class="string">'fexo'</span> (git://github.com/XiaoliangHuang/fexo.git) registered <span class="keyword">for</span> path <span class="string">'fexo'</span></div><div class="line"> </div><div class="line">$ git submodule update</div><div class="line">Cloning into <span class="string">'D:/Test/git submodule/MyRepo_2/test/fexo'</span>...</div><div class="line">Submodule path <span class="string">'fexo'</span>: checked out <span class="string">'6cce4cbbd0d27ce7d4207f932bcecb762958be98'</span></div><div class="line"> </div><div class="line">$ git submodule status</div><div class="line"> 6cce4cbbd0d27ce7d4207f932bcecb762958be98 fexo (v1.0.0-58-g6cce4cb)</div></pre></td></tr></table></figure>
<p>进入到submodule的folder以后，会看到这个时候head 并没有指向某个branch, 比如master，而是处于游离的状态：<br><figure class="highlight applescript"><table><tr><td class="code"><pre><div class="line">$ git status</div><div class="line">HEAD detached <span class="keyword">at</span> <span class="number">6</span>cce4cb</div><div class="line">nothing <span class="keyword">to</span> commit, working tree clean</div></pre></td></tr></table></figure></p>
<p>这时候就需要在里面使用 <strong>git checkout master</strong> 命令切换到master branch了，不然以后在submit 和push的时候会出错。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ git checkout master</div><div class="line">Switched to branch <span class="string">'master'</span></div><div class="line">Your branch is up-to-date with <span class="string">'origin/master'</span>.</div><div class="line"> </div><div class="line">$ git status</div><div class="line">On branch master</div><div class="line">Your branch is up-to-date with <span class="string">'origin/master'</span>.</div><div class="line">nothing to commit, working tree clean</div></pre></td></tr></table></figure>
<h3 id="更新一个submodule"><a href="#更新一个submodule" class="headerlink" title="更新一个submodule"></a>更新一个submodule</h3><p>一个submodule就是一个完整的git repository，所以切到submodule的目录以后，就可以使用git的常规命令来进行操作了。</p>
<p>在更新之前，需要注意的是init update下来的submodule是否是在制定的branch上面，比如master，否则需要先用 git checkout master 来进行切换操作。</p>
<h3 id="删除一个submodule"><a href="#删除一个submodule" class="headerlink" title="删除一个submodule"></a>删除一个submodule</h3><h2 id="Paging-分页器"><a href="#Paging-分页器" class="headerlink" title="Paging 分页器"></a>Paging 分页器</h2><p>这部分内容摘自 <a href="http://gotgit.readthedocs.io/en/latest/01-meet-git/020-love-git.html#git" target="_blank" rel="external">爱上Git的理由</a></p>
<p>虽然拥有图形化的客户端，但Git更有效率的操作方式还是命令行操作。使用命令行操作的好处一个是快，另外一个就是防止鼠标手的出现。Git的命令行进行了大量的人性化设计，包括命令补全、彩色字符输出等，不过最具特色的还是无处不在的分页器。</p>
<p>在操作其他版本控制系统的命令行时，如果命令的输出超过了一屏，为了能够逐屏显示，需要在命令的后面加上一个管道符号将输出交给一个分页器。例如：<br><figure class="highlight gams"><table><tr><td class="code"><pre><div class="line"><span class="symbol">$</span> svn <span class="built-in">log</span> | less</div></pre></td></tr></table></figure></p>
<p>而Git则不用如此麻烦，因为常用的Git的命令都带有一个分页器，当一屏显示不下时启动分页器。分页器默认使用less命令（less -FRSX）进行分页。</p>
<p>因为less分页器在翻屏时使用了vi风格的热键，如果您不熟悉vi的话，可能会遇到麻烦。下面是在分页器中常用的热键：<br><figure class="highlight haml"><table><tr><td class="code"><pre><div class="line">-<span class="ruby"> q：退出分页器。</span></div><div class="line">-<span class="ruby"> h：显示分页器帮助。</span></div><div class="line">-<span class="ruby"> 空格: 下翻一页</span></div><div class="line">-<span class="ruby"> <span class="symbol">b:</span> 上翻一页。</span></div><div class="line">-<span class="ruby"> d/u：分别代表向下翻动半页和向上翻动半页。</span></div><div class="line">-<span class="ruby"> j/k：分别代表向上翻一行和向下翻一行。</span></div><div class="line">-<span class="ruby"> 如果行太长被截断，可以用左箭头和右箭头使得窗口内容左右滚动。</span></div><div class="line">-<span class="ruby"> 输入/pattern：向下寻找和pattern匹配的内容。</span></div><div class="line">-<span class="ruby"> 输入?pattern：向上寻找和pattern匹配的内容。</span></div><div class="line">-<span class="ruby"> 字母n或N：代表向前或向后继续寻找。</span></div><div class="line">-<span class="ruby"> 字母g：跳到第一行；字母G：跳到最后一行；输入数字再加字母g：则跳转到对应的行。</span></div><div class="line">-<span class="ruby"> 输入!&lt;command&gt;：可以执行Shell命令。</span></div></pre></td></tr></table></figure></p>
<p>对于默认未提供分页器的Git命令，例如git status命令，可以通过下面任一方法启用分页器：</p>
<p>在git和子命令（如status）之间插入参数-p或–paginate，为命令启用内建分页器。如：<br><figure class="highlight stylus"><table><tr><td class="code"><pre><div class="line">$ git -<span class="selector-tag">p</span> status</div></pre></td></tr></table></figure></p>
<p>设置Git配置变量，设置完毕后运行相应的命令，将启用内建分页器。<br><figure class="highlight autoit"><table><tr><td class="code"><pre><div class="line">$ git config --<span class="keyword">global</span> pager.status <span class="literal">true</span></div></pre></td></tr></table></figure></p>
<p>Git命令的分页器支持带颜色的字符输出，对于太长的行则采用截断方式处理（可用左右方向键滚动）。如果不习惯分页器的长行截断模式而希望采用自动折行模式，可以通过下面任一方法进行设置：</p>
<p>通过设置LESS环境变量来实现。<br><figure class="highlight cmake"><table><tr><td class="code"><pre><div class="line">$ <span class="keyword">export</span> <span class="keyword">LESS</span>=FRX</div></pre></td></tr></table></figure></p>
<p>或者通过定义Git配置变量来改变分页器的默认行为。<br><figure class="highlight stylus"><table><tr><td class="code"><pre><div class="line">$ git config --global core<span class="selector-class">.pager</span> <span class="string">'less -+$LESS -FRX'</span></div></pre></td></tr></table></figure></p>
<h1 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h1><h2 id="Config-Git–局部设置与全局设置"><a href="#Config-Git–局部设置与全局设置" class="headerlink" title="Config Git–局部设置与全局设置"></a>Config Git–局部设置与全局设置</h2><p>最开始使用 git 的时候，都是按照网上的介绍 step by step，然后切到一个新的地方，就会发现一些奇怪的事情，比如说，我安装了Git的时候，是用来sync BitBucket上面的Repository的，但是后来用来处理Github上面的Repository为什么记录里面显示的还是之前的BitBucket账号提交的呢？</p>
<p>原因就是Git的的设置方式。有全局设置和局部设置</p>
<h3 id="局部设置"><a href="#局部设置" class="headerlink" title="局部设置"></a>局部设置</h3><p>当你Init或者Clone一个Git Repository的时候，Git都会在指定目录（一般是当前目录）建立一个.git的文件夹，用来保存当前Repository的相关内容，跟这个Repository相关的设置也在这个目录当中，保存在一个名为config的文件当中<br><figure class="highlight haml"><table><tr><td class="code"><pre><div class="line">-<span class="ruby">-.git</span></div><div class="line">  |</div><div class="line">  -<span class="ruby">-config</span></div></pre></td></tr></table></figure></p>
<p>其中的内容是诸如下面的config<br><figure class="highlight coffeescript"><table><tr><td class="code"><pre><div class="line">[remote <span class="string">"Hexo"</span>]</div><div class="line">	url = https:<span class="regexp">//gi</span>thub.com/laomanco/Hexo.git</div><div class="line">	fetch = +refs<span class="regexp">/heads/</span>*:refs<span class="regexp">/remotes/Hexo/</span>*</div><div class="line">[branch <span class="string">"master"</span>]</div><div class="line">	remote = Hexo</div><div class="line">	merge = refs/heads/master</div><div class="line">[user]</div><div class="line">    name = laomanco</div><div class="line">    email =laomanco@gmail.com</div></pre></td></tr></table></figure></p>
<p>除了直接修改config文件，还可以通过命令行来进行设置，例如，要设置当前Git Repository Commit 等等的用户信息</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><div class="line">$ git config user<span class="selector-class">.name</span> laomanco</div><div class="line">$ git config user<span class="selector-class">.email</span> laomanco@gmail.com</div></pre></td></tr></table></figure>
<p>要查看config的内容的话，用get命令就可以，更多具体内容可以参考<a href="https://cnbin.github.io/blog/2015/06/19/git-config-ming-ling-cha-kan-pei-zhi-wen-jian/" target="_blank" rel="external">Git Config 命令查看配置文件</a><br><figure class="highlight arduino"><table><tr><td class="code"><pre><div class="line">$ git <span class="built_in">config</span> --<span class="built_in">get</span> user.name</div><div class="line">laomanco</div></pre></td></tr></table></figure></p>
<h3 id="全局设置"><a href="#全局设置" class="headerlink" title="全局设置"></a>全局设置</h3><p>在安装Git的时候，系统就会为当前用户添加一个全局的系统设置，存放在下面的目录当中</p>
<figure class="highlight taggerscript"><table><tr><td class="code"><pre><div class="line">C:<span class="symbol">\U</span>sers<span class="symbol">\&lt;</span>username&gt;<span class="symbol">\.</span>gitconfig</div></pre></td></tr></table></figure>
<p>里面包含的config内容格式与局部config非常的类型，也可以通过修改文件和命令行的方式进行修改，不过通过命令行进行设置的时候，需要在config命令里面加上–global的参数</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><div class="line">$ git <span class="built_in">config</span> <span class="comment">--global user.name laomanco</span></div><div class="line">$ git <span class="built_in">config</span> <span class="comment">--global user.email laomanco@gmail.com</span></div><div class="line">$ git <span class="built_in">config</span> <span class="comment">--global --get user.name</span></div></pre></td></tr></table></figure>
<h2 id="Git-在-windows-下中文乱码"><a href="#Git-在-windows-下中文乱码" class="headerlink" title="Git 在 windows 下中文乱码"></a>Git 在 windows 下中文乱码</h2><p>在windows下面使用git来添加中文名称的文件名的时候，会遇到类似于下面的，文件名被转码，无法识别的问题：<br><figure class="highlight lsl"><table><tr><td class="code"><pre><div class="line">\<span class="number">316</span>\<span class="number">304</span>\<span class="number">261</span>\<span class="number">276</span>\<span class="number">316</span>\<span class="number">304</span>\<span class="number">265</span>\<span class="number">265.</span>md</div></pre></td></tr></table></figure></p>
<p>其原因是 Git 使用的是 utf-8 的编码方式，而在windows下面默认采用的则是Unicode，因而出现了编码和解码不一致的问题。解决的方法是在git上面进行下面的设置, 让git支持utf-8编码 ( <a href="https://gist.github.com/nightire/5069597" target="_blank" rel="external">解决 Git 在 windows 下中文乱码的问题</a> ) ：<br><figure class="highlight coffeescript"><table><tr><td class="code"><pre><div class="line">$ git config --<span class="built_in">global</span> core.quotepath <span class="literal">false</span>  		<span class="comment"># 显示 status 编码</span></div><div class="line">$ git config --<span class="built_in">global</span> gui.encoding utf<span class="number">-8</span>			<span class="comment"># 图形界面编码</span></div><div class="line">$ git config --<span class="built_in">global</span> i18n.commit.encoding utf<span class="number">-8</span>	<span class="comment"># 提交信息编码</span></div><div class="line">$ git config --<span class="built_in">global</span> i18n.logoutputencoding utf<span class="number">-8</span>	<span class="comment"># 输出 log 编码</span></div><div class="line">$ <span class="keyword">export</span> LESSCHARSET=utf<span class="number">-8</span></div><div class="line"><span class="comment"># 最后一条命令是因为 git log 默认使用 less 分页，所以需要 bash 对 less 命令进行 utf-8 编码</span></div></pre></td></tr></table></figure></p>
<h1 id="Rerence"><a href="#Rerence" class="headerlink" title="Rerence"></a>Rerence</h1><p><a href="http://gotgit.readthedocs.io/en/latest/01-meet-git/010-scm-history.html#cvs" target="_blank" rel="external">版本控制的前世和今生</a></p>
<p><a href="https://www.git-tower.com/learn/git/ebook/cn/command-line/appendix/why-git" target="_blank" rel="external">为什么选择 Git</a></p>
<p><a href="http://gotgit.readthedocs.io/en/latest/01-meet-git/020-love-git.html#git" target="_blank" rel="external">爱上Git的理由</a></p>
<p><a href="http://www.cnblog.me/2016/04/04/git-permissions/" target="_blank" rel="external">Git 权限控制</a></p>
<p><a href="https://cnbin.github.io/blog/2015/06/19/git-config-ming-ling-cha-kan-pei-zhi-wen-jian/" target="_blank" rel="external">Git Config 命令查看配置文件</a></p>
<p><a href="http://linlexus.com/git-submodule-usage/" target="_blank" rel="external">如何使用 Git Submodule</a></p>
<p><a href="http://blog.devtang.com/2013/05/08/git-submodule-issues/" target="_blank" rel="external">Git submodule的坑</a></p>
<p><a href="https://gist.github.com/nightire/5069597" target="_blank" rel="external">解决 Git 在 windows 下中文乱码的问题</a></p>
<p><a href="http://teohm.com/blog/learning-git-internals-by-example/" target="_blank" rel="external">Learning Git Internals by Example</a></p>
<p><a href="http://blog.xiayf.cn/2013/09/28/learning-git-internals-by-example/" target="_blank" rel="external">通过示例学习Git内部构造（译）</a></p>
<p><a href="http://huanglei.me/git-theory.html" target="_blank" rel="external">图解git – 用图片分析学习git原理</a></p>

    
  </div>
</article>

</div>


  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">关闭</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/archives/"
              target="_self"
              >
              博客
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/category/"
              target="_self"
              >
              分类
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/tag/"
              target="_self"
              >
              标签
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/link/"
              target="_self"
              >
              友链
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/about/"
              target="_self"
              >
              关于
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    

    




    

	<hr />
	<div id="hypercomments_widget"></div>
	<script type="text/javascript">
	_hcwp = window._hcwp || [];

	_hcwp.push({widget:"Stream", widget_id: '88547'});

	(function() {

	if("HC_LOAD_INIT" in window) return;

	HC_LOAD_INIT = true;

	var lang = (navigator.language || navigator.systemLanguage || navigator.userLanguage || "en").substr(0, 2).toLowerCase();

	var hcc = document.createElement("script"); 
	hcc.type = "text/javascript"; 
	hcc.async = true;
	hcc.src = ("https:" == document.location.protocol ? "https" : "http")+"://w.hypercomments.com/widget/hc/"+'88547' +"/"+lang+"/widget.js";

	var s = document.getElementsByTagName("script")[0];
	s.parentNode.insertBefore(hcc, s.nextSibling);
	})();

	</script>

	<a href="http://hypercomments.com" class="hc-link" title="comments widget">Powered by HyperComments</a>


	
  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });
  }
</script>

</body>
</html>
